/*************************************************************************
  ✅ CA Parks — Local-clock countdown + single click + logging
  - Uses ONLY local time (Date.now)
  - Always-visible countdown (updates every 200ms)
  - High-precision final 5s loop + optional beeps
  - Safe single click at T=0 (+ manual ms adjust) on BUTTON_SEL
  - Logs: clock source, click timing error (Δclick), and outcome signals
*************************************************************************/
(() => {
  /* ===== CONFIG ===== */
  const TARGET_H = 17,
    TARGET_M = 28,
    TARGET_S = 0,
    TARGET_MS = 0; // target time local
  // Primary click target selector for the current page.
  // If not found at click time, we fall back to a best-effort "Reserve Unit" button finder.
  const BUTTON_SEL = "#checkout-button";
  const DRY_RUN = false;
  const BEEP = true;

  // Manual timing adjustment
  // negative = earlier, positive = later
  const CLICK_ADJUST_MS = -1150; // you’re testing -1000, -1500, etc.

  // Outcome detection window after click
  const OUTCOME_TIMEOUT_MS = 10000;  // Increased for peak traffic congestion

  // Optional: if you know cart count selector, put it here (else heuristic)
  const CART_COUNT_SEL = null;

  // Optional: lightweight same-origin probe used ONLY for logging server Date at click time.
  // If you don't want *any* extra requests, set SERVER_PROBE_URL = null.
  const SERVER_PROBE_URL = `${location.origin}/favicon.ico?rcx=${Date.now()}`;
  /* ================== */

  // ===== Network timing hooks (fetch + XHR) =====
  window.__rcxNet = window.__rcxNet || [];
  const RCX_DENY = [
    "google-analytics.com",
    "facebook.com/tr",
    "doubleclick.net",
    "googletagmanager.com",
  ];

  const RCX_NET_MATCH = [
    "recreation-management.tylerapp.com/rdr/",
    "/rdr/",
    "/Facilities/",
    "SelectReservationPreCart",
    "PreCart",
    "ShoppingCart",
    "AddToCart",
    "Hold",
    "rdapi.reservecalifornia.com",  // API calls
    "/api/webaccessfacility/",       // Facility access API
  ];

  function rcxIsInterestingUrl(url) {
    try {
      const u = String(url);
      if (RCX_DENY.some((d) => u.includes(d))) return false;
      return RCX_NET_MATCH.some((s) => u.includes(s));
    } catch {
      return false;
    }
  }

  function rcxTrimUrl(url) {
    try {
      const u = new URL(url, location.href);
      // keep path + key query bits; strip noisy params
      return (
        u.origin + u.pathname + (u.search ? u.search.slice(0, 120) : "")
      );
    } catch {
      return String(url).slice(0, 200);
    }
  }

  // Hook fetch
  (() => {
    const _fetch = window.fetch;
    if (!_fetch || _fetch.__rcxHooked) return;

    async function wrappedFetch(input, init) {
      const url =
        typeof input === "string"
          ? input
          : input && input.url
            ? input.url
            : String(input);
      const interesting = rcxIsInterestingUrl(url);

      const t0 = performance.now();
      try {
        const res = await _fetch(input, init);
        const t1 = performance.now();

        if (interesting) {
          const entry = {
            kind: "fetch",
            tsIso: new Date().toISOString(),
            url: rcxTrimUrl(url),
            status: res.status,
            durMs: Math.round(t1 - t0),
          };
          window.__rcxNet.push(entry);
          console.log("[rcx][net]", entry);
        }
        return res;
      } catch (err) {
        const t1 = performance.now();
        if (interesting) {
          const entry = {
            kind: "fetch",
            tsIso: new Date().toISOString(),
            url: rcxTrimUrl(url),
            status: null,
            error: String(err && err.message ? err.message : err),
            durMs: Math.round(t1 - t0),
          };
          window.__rcxNet.push(entry);
          console.log("[rcx][net]", entry);
        }
        throw err;
      }
    }

    wrappedFetch.__rcxHooked = true;
    window.fetch = wrappedFetch;
  })();

  // Hook XHR
  (() => {
    const _open = XMLHttpRequest.prototype.open;
    const _send = XMLHttpRequest.prototype.send;
    if (_send.__rcxHooked) return;

    XMLHttpRequest.prototype.open = function (method, url, ...rest) {
      this.__rcx = { method, url: String(url) };
      return _open.call(this, method, url, ...rest);
    };

    XMLHttpRequest.prototype.send = function (...args) {
      const meta = this.__rcx || { method: "?", url: "?" };
      const interesting = rcxIsInterestingUrl(meta.url);
      const t0 = performance.now();

      const done = () => {
        const t1 = performance.now();
        if (!interesting) return;
        const entry = {
          kind: "xhr",
          tsIso: new Date().toISOString(),
          method: meta.method,
          url: rcxTrimUrl(meta.url),
          status:
            typeof this.status === "number" ? this.status : null,
          durMs: Math.round(t1 - t0),
        };
        window.__rcxNet.push(entry);
        console.log("[rcx][net]", entry);
      };

      this.addEventListener("loadend", done, { once: true });
      return _send.apply(this, args);
    };

    XMLHttpRequest.prototype.send.__rcxHooked = true;
  })();

  // ===== Beacon timing hook =====
  (() => {
    const orig = navigator.sendBeacon;
    if (!orig || orig.__rcxHooked) return;

    navigator.sendBeacon = function (url, data) {
      const t0 = performance.now();
      const ok = orig.call(this, url, data);
      const t1 = performance.now();

      const entry = {
        kind: "beacon",
        tsIso: new Date().toISOString(),
        url: String(url).slice(0, 220),
        ok,
        durMs: Math.round(t1 - t0),
      };
      window.__rcxNet.push(entry);
      console.log("[rcx][net]", entry);
      return ok;
    };

    navigator.sendBeacon.__rcxHooked = true;
  })();

  // Overlay (top-right)
  const css = `
        #rcx{position:fixed;top:16px;right:16px;z-index:2147483647;
        background:rgba(6,78,59,.92);color:#fff;padding:10px 14px;border-radius:12px;
        box-shadow:0 8px 18px rgba(0,0,0,.25);font:700 18px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
        pointer-events:none}
        #rcx b{font-size:22px} #rcx small{opacity:.9;font-weight:600}
        #rcx mark{background:#fff;color:#064e3b;padding:0 .3rem;border-radius:6px}
        .rcx-hl{outline:3px solid #0ea5e9 !important;scroll-margin:80px}
    `;
  const st = document.createElement("style");
  st.textContent = css;
  document.head.appendChild(st);
  const box = document.createElement("div");
  box.id = "rcx";
  box.innerHTML = `<div><b id="rcx_t">--:--.––</b> <small id="rcx_s">local clock</small></div>
                    <div><small>Target: <mark id="rcx_target">--:--:--</mark></small></div>
                    <div><small>Fire@ (adj): <mark id="rcx_fire">--:--:--</mark></small></div>`;
  document.body.appendChild(box);
  const $ = (id) => document.getElementById(id);

  // Attempt history
  window.__rcxAttempts = window.__rcxAttempts || [];

  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  const clampText = (s, n = 200) =>
    (s || "").replace(/\s+/g, " ").trim().slice(0, n);

  // Build next target time (local)
  function buildTarget(baseNow) {
    const t = new Date(baseNow);
    t.setHours(TARGET_H, TARGET_M, TARGET_S, TARGET_MS);
    if (t.getTime() <= baseNow) t.setDate(t.getDate() + 1);
    return t;
  }

  // Button helpers
  function btn() {
    // IMPORTANT: this is the fire-time click target.
    // Do not fall back to other buttons here (Reserve Unit is used only for outcome detection).
    return document.querySelector(BUTTON_SEL);
  }

  function findReserveUnitButton() {
    return (
      document.getElementById("precart_submit_btn") ||
      document.getElementById("precart_sumbit_btn") ||
      [...document.querySelectorAll('button[type="submit"], button')].find(
        (b) => /\breserve\s+unit\b/i.test((b && b.textContent) || "")
      ) ||
      null
    );
  }
  function highlight(el) {
    if (!el) return;
    el.classList.add("rcx-hl");
    el.scrollIntoView({ behavior: "smooth", block: "center" });
  }

  // Best-effort cart count
  function getCartCount() {
    try {
      if (CART_COUNT_SEL) {
        const el = document.querySelector(CART_COUNT_SEL);
        const n = el ? parseInt(el.textContent.trim(), 10) : NaN;
        return Number.isFinite(n) ? n : null;
      }
      // heuristic: look for cart-ish elements that include a number badge
      const cartish = [...document.querySelectorAll("a,button,span,div")]
        .filter(
          (el) =>
            /cart/i.test(el.getAttribute("aria-label") || "") ||
            /cart/i.test(el.textContent || "")
        )
        .slice(0, 60);

      for (const el of cartish) {
        const txt = (el.textContent || "").trim();
        const m = txt.match(/\b(\d{1,2})\b/);
        if (m) return parseInt(m[1], 10);
      }
    } catch {}
    return null;
  }

  // Best-effort modal/error message
  function getModalText() {
    try {
      // First try the specific alert message element (most reliable)
      const alertMsg = document.getElementById('alertModalMessage');
      if (alertMsg && alertMsg.textContent) {
        const t = clampText(alertMsg.textContent, 240);
        if (t) return t;
      }

      // Fallback: Prioritize modal-body over full modal to get actual error message
      const bodySelectors = '.modal-body, [class*="modal"] .body, [role="dialog"] p';
      const modalSelectors = '[role="dialog"], .modal-dialog, .modal-content, .modal';
      
      // Try body/content first (more specific)
      let candidates = [...document.querySelectorAll(bodySelectors)];
      if (candidates.length === 0) {
        // Fallback to full modal containers
        candidates = [...document.querySelectorAll(modalSelectors)];
      }
      
      const modals = candidates.filter((el) => {
        if (!el) return false;
        if (el.offsetParent !== null) return true;
        if (document.body.classList.contains('modal-open')) return true;
        return false;
      });

      for (const m of modals) {
        const t = clampText(m.textContent, 240);
        if (t && t.length > 20) return t;
      }
    } catch {}
    return null;
  }

  // Outcome watcher
  async function watchOutcome({
    startUrl,
    startCartCount,
    timeoutMs = 5000,
  }) {
    const tStart = performance.now();

    return new Promise((resolve) => {
      let done = false;
      const finish = (result) => {
        if (done) return;
        done = true;
        try {
          obs.disconnect();
        } catch {}
        resolve({
          ...result,
          dtMs: Math.round(performance.now() - tStart),
          endUrl: location.href,
          endCartCount: getCartCount(),
          modalText: getModalText(),
        });
      };

      const check = () => {
        const urlNow = location.href;

        // URL became cart-ish
        if (
          urlNow !== startUrl &&
          /cart|checkout|precart|ReservationPreCart|ShoppingCart/i.test(
            urlNow
          )
        ) {
          // Wait briefly for modals to render before deciding success/failure
          // Modals often appear 300-500ms after URL change
          setTimeout(() => {
            if (done) return; // Already finished by another check
            
            // Check for Reserve Unit button FIRST - most reliable success indicator
            const reserveBtn = findReserveUnitButton();
            
            if (reserveBtn) {
              // Button present = successful reservation (even if policy modal showing)
              finish({
                ok: true,
                reason: "Reserve Unit button present",
              });
              return;
            }
            
            // No button - check if error modal explains why
            const mt = getModalText();
            const hasErrorModal = mt && /not available|not permitted|restriction|choose a new stay|not allowed|unable|policy change|last allowed arrival date|booking restriction/i.test(mt);
            
            if (hasErrorModal) {
              // Navigation happened but with error modal - classify error type
              // Check critical errors first (restriction/sold-out), then policy change
              const isTooEarly = /arrival date booking restriction|last allowed arrival date|not permitted according to|restriction list/i.test(mt);
              const isSoldOut = /no longer available|not available|already reserved|in another.*cart/i.test(mt);
              const isPolicyChange = /policy change effective|alert type.*camping/i.test(mt);
              
              const errorType = isTooEarly ? "too-early" : isSoldOut ? "sold-out" : isPolicyChange ? "policy-change" : "unknown";
              
              finish({
                ok: false,
                reason: `Cart route with error: ${errorType}`,
                errorDetail: clampText(mt, 150)
              });
            } else {
              // No button, no error modal - ambiguous
              finish({
                ok: true,
                reason: "URL changed to cart-ish route",
              });
            }
          }, 3000); // Wait 3s for modal rendering - plenty fast for user review
          return;
        }

        // Cart count increased
        const cc = getCartCount();
        if (
          startCartCount != null &&
          cc != null &&
          cc > startCartCount
        ) {
          finish({
            ok: true,
            reason: `Cart count increased (${startCartCount}→${cc})`,
          });
          return;
        }

        // Error modal detected
        const mt = getModalText();
        if (
          mt &&
          /not available|not permitted|restriction|choose a new stay|not allowed|unable|policy change|last allowed arrival date|booking restriction/i.test(
            mt
          )
        ) {
          // Distinguish error types - check critical errors first (restriction/sold-out), then policy
          const isTooEarly = /arrival date booking restriction|last allowed arrival date|not permitted according to|restriction list/i.test(mt);
          const isSoldOut = /no longer available|not available|already reserved|in another.*cart/i.test(mt);
          const isPolicyChange = /policy change effective|alert type.*camping/i.test(mt);
          
          const errorType = isTooEarly ? "too-early" : isSoldOut ? "sold-out" : isPolicyChange ? "policy-change" : "unknown";
          
          finish({ 
            ok: false, 
            reason: `Error modal: ${errorType}`,
            errorDetail: clampText(mt, 150)
          });
          return;
        }

        // Timeout
        if (performance.now() - tStart >= timeoutMs) {
          finish({ ok: null, reason: "No clear signal (timeout)" });
        }
      };

      const obs = new MutationObserver(check);
      obs.observe(document.documentElement, {
        subtree: true,
        childList: true,
        attributes: true,
      });
      const poll = setInterval(() => {
        if (done) return clearInterval(poll);
        check();
      }, 150);

      check();
    });
  }

  // Safe single click
  function safeClick() {
    const b = btn();
    if (!b) {
      console.log("[rcx] No button to click");
      return false;
    }
    if (DRY_RUN) {
      console.log("[rcx] DRY RUN: would click", b);
      return true;
    }
    console.log("[rcx] CLICK");
    b.dispatchEvent(
      new MouseEvent("click", { bubbles: true, cancelable: true })
    );
    if (typeof b.click === "function") b.click();
    return true;
  }

  // Optional beep
  let beep = () => {};
  if (BEEP)
    try {
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      beep = (f = 880, d = 90, g = 0.16) => {
        const o = ac.createOscillator(),
          G = ac.createGain();
        o.type = "square";
        o.frequency.value = f;
        G.gain.value = g;
        o.connect(G);
        G.connect(ac.destination);
        o.start();
        setTimeout(() => o.stop(), d);
      };
    } catch {}

  async function logClickAttempt({ fireAtMs, startUrl, startCartCount }) {
    const actualMs = Date.now();
    const perfAtClick = performance.now();
    const deltaMs = actualMs - fireAtMs; // +late, -early

    // Optional: server Date header at click time (best-effort)
    let serverDateMs = null;
    if (SERVER_PROBE_URL) {
      try {
        const r = await fetch(SERVER_PROBE_URL, {
          cache: "no-store",
          credentials: "same-origin",
        });
        const dh = r.headers.get("date");
        if (r.ok && dh) serverDateMs = new Date(dh).getTime();
      } catch {}
    }

    const record = {
      tsIso: new Date().toISOString(),
      clockSource: "LOCAL",
      clickAdjustMs: CLICK_ADJUST_MS,
      scheduledFireAtMs: fireAtMs,
      actualAtClickMs: actualMs,
      deltaMs: Math.round(deltaMs),
      serverDateMs,
      urlAtClick: startUrl,
      cartCountBefore: startCartCount,
    };

    window.__rcxAttempts.push(record);
    console.log("[rcx] CLICK TIMING", record);

    $("rcx_s").textContent += ` | LOCAL | Δclick ${Math.round(deltaMs)}ms`;
    // NOTE: server Date headers are often rounded/cached; keep serverDateMs in record but don't display it
    // if (serverDateMs != null) $('rcx_s').textContent += ` | srv ${new Date(serverDateMs).toLocaleTimeString()}`;

    // Watch outcome and attach it
    const out = await watchOutcome({
      startUrl,
      startCartCount,
      timeoutMs: OUTCOME_TIMEOUT_MS,
    });

    const summary = {
      ok: out.ok,
      reason: out.reason,
      dtMs: out.dtMs,
      endUrl: out.endUrl,
      endCartCount: out.endCartCount,
      modalText: out.modalText,
    };

    // Attach network hook timings (netHook provides complete, unmasked API timing data)
    try {
      const hookData = window.__rcxNet.slice(-30);
      const hookBest =
        hookData.sort((a, b) => (b.durMs || 0) - (a.durMs || 0))[0] ||
        null;
      record.netHook = { sampleCount: hookData.length, best: hookBest, recent: hookData.slice(0, 8) };
    } catch {}

    // Persist back onto the last attempt
    window.__rcxAttempts[window.__rcxAttempts.length - 1] = {
      ...window.__rcxAttempts[window.__rcxAttempts.length - 1],
      netHook: record.netHook,
      outcome: summary,
    };

    console.log("[rcx] OUTCOME", summary);

    const tag =
      out.ok === true
        ? "SUCCESS?"
        : out.ok === false
          ? "FAIL"
          : "UNKNOWN";
    $("rcx_s").textContent +=
      ` | ${tag}: ${clampText(out.reason, 60)} | dt ${out.dtMs}ms`;
  }

  (async () => {
    $("rcx_s").textContent = "LOCAL clock (no sync)";
    const target = buildTarget(Date.now());
    const fireAt = new Date(target.getTime() + CLICK_ADJUST_MS);

    $("rcx_target").textContent = target.toLocaleTimeString();
    $("rcx_fire").textContent =
      fireAt.toLocaleTimeString() +
      (CLICK_ADJUST_MS ? ` (${CLICK_ADJUST_MS}ms)` : "");

    // Pre-warm API connection 10s before target time
    const warmupDelay = Math.max(0, fireAt - Date.now() - 10000);
    setTimeout(async () => {
      try {
        // Lightweight HEAD request to establish connection
        await fetch("https://rdapi.reservecalifornia.com/api/webaccessfacility/check/restractionsforbooking", {
          method: "HEAD",
          mode: "no-cors" // Won't actually succeed, but opens connection
        }).catch(() => {});
        console.log("[rcx] API connection pre-warmed");
        $("rcx_s").textContent += " | conn warmed";
      } catch {}
    }, warmupDelay);

    // Arm/highlight when button appears
    const arm = setInterval(() => {
      const b = btn();
      if (b) {
        highlight(b);
        $("rcx_s").textContent += " | button armed";
        clearInterval(arm);
      }
    }, 200);

    // Base countdown
    let baseTimer = setInterval(() => {
      const now = Date.now();
      const diff = fireAt - now;
      const mm = Math.max(0, Math.floor(diff / 60000));
      const ss = Math.max(0, Math.floor((diff % 60000) / 1000));
      const cs = Math.max(0, Math.floor((diff % 1000) / 10));
      $("rcx_t").textContent =
        `${String(mm).padStart(2, "0")}:${String(ss).padStart(2, "0")}.${String(cs).padStart(2, "0")}`;
    }, 200);

    // High precision in last 5 seconds
    const preDelay = Math.max(0, fireAt - Date.now() - 5000);

    setTimeout(() => {
      clearInterval(baseTimer);

      (function tick() {
        const now = Date.now();
        const diff = fireAt - now;

        if (diff <= 0) {
          $("rcx_t").textContent = "00:00.00";
          $("rcx_s").textContent += " | GO";

          const startUrl = location.href;
          const startCartCount = getCartCount();
          const fireAtMs = fireAt.getTime();

          const clicked = safeClick();
          if (clicked)
            logClickAttempt({ fireAtMs, startUrl, startCartCount });

          return;
        }

        const mm = Math.floor(diff / 60000);
        const ss = Math.floor((diff % 60000) / 1000);
        const cs = Math.floor((diff % 1000) / 10);
        $("rcx_t").textContent =
          `${String(mm).padStart(2, "0")}:${String(ss).padStart(2, "0")}.${String(cs).padStart(2, "0")}`;

        if (mm === 0 && ss <= 5) beep(880, 80, 0.2);
        requestAnimationFrame(tick);
      })();
    }, preDelay);
  })();
})();
