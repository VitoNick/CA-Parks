/*************************************************************************
  ✅ CA Parks — Always-visible countdown + single human-like click
  - Shows countdown immediately (updates every 200ms)
  - Same-origin HEAD Date-header time sync (best RTT) + jitter estimate
  - Re-sync at T-30s (optional) with "trust gate"
  - Switches to high-precision loop + beeps only in last 5s
  - Safe single click at T=0 (+ manual ms adjust) on #checkout-button
*************************************************************************/
(() => {
  /* ===== CONFIG ===== */
  const TARGET_H=8, TARGET_M=0, TARGET_S=0, TARGET_MS=0; // change if needed
  const BUTTON_SEL = '#checkout-button';
  const DRY_RUN = false;    // true = no click, only logs/highlight
  const BEEP = true;        // beeps only in the final 5 seconds

  // ✅ Manual click timing adjustment (ms)
  // negative = earlier, positive = later
  const CLICK_ADJUST_MS = -500; // try -80, -100, -120, etc.

  // ✅ Time sync config (SAME-ORIGIN)
  // Uses HEAD request to current page URL to read Date header reliably.
  const TIME_SYNC_URL = `${location.origin}/favicon.ico?rcx=${Date.now()}`;  const TIME_SAMPLES = 11;
  const TIME_TIMEOUT_MS = 1200;

  // ✅ Re-sync config (T-30s)
  const RESYNC_ENABLED = true;
  const RESYNC_AT_MS_BEFORE = 30_000;
  const RESYNC_SAMPLES = 5;
  const RESYNC_TIMEOUT_MS = 900;

  // ✅ Trust gate: only accept sync if it looks clean
  // Tune thresholds to taste.
  const TRUST_MAX_RTT_MS = 180;
  const TRUST_MAX_JITTER_MS = 120;
  /* ================== */
  
  // Overlay (top-right)
  const css = `
    #rcx{position:fixed;top:16px;right:16px;z-index:2147483647;
      background:rgba(6,78,59,.92);color:#fff;padding:10px 14px;border-radius:12px;
      box-shadow:0 8px 18px rgba(0,0,0,.25);font:700 18px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      pointer-events:none}
    #rcx b{font-size:22px} #rcx small{opacity:.9;font-weight:600}
    #rcx mark{background:#fff;color:#064e3b;padding:0 .3rem;border-radius:6px}
    .rcx-hl{outline:3px solid #0ea5e9 !important;scroll-margin:80px}
  `;
  const st=document.createElement('style'); st.textContent=css; document.head.appendChild(st);
  const box=document.createElement('div'); box.id='rcx';
  box.innerHTML=`<div><b id="rcx_t">--:--.––</b> <small id="rcx_s">syncing…</small></div>
                 <div><small>Target: <mark id="rcx_target">--:--:--</mark></small></div>
                 <div><small>Fire@ (adj): <mark id="rcx_fire">--:--:--</mark></small></div>`;
  document.body.appendChild(box);
  const $ = id => document.getElementById(id);

  // Time helpers
  function buildTarget(baseNow){
    const t=new Date(baseNow); t.setHours(TARGET_H,TARGET_M,TARGET_S,TARGET_MS);
    if (t.getTime()<=baseNow) t.setDate(t.getDate()+1);
    return t;
  }

  function isGoodSync(s){
    if (!s || s.bestRttMs == null) return false;
    if (s.bestRttMs > TRUST_MAX_RTT_MS) return false;
    if ((s.jitterMs ?? 999999) > TRUST_MAX_JITTER_MS) return false;
    return true;
  }

  function fmtSync(sync, label){
    if (!sync || sync.bestRttMs == null) return `${label}: local clock`;
    const o = Math.round(sync.offsetMs);
    const j = Math.round(sync.jitterMs ?? 0);
    const r = Math.round(sync.bestRttMs);
    return `${label}: off ${o}ms | jit ${j}ms | rtt ${r}ms | n=${sync.samplesUsed}`;
  }

  // --- SAME-ORIGIN multi-sample time sync (best RTT) + jitter ---
    async function syncOffset({ url, samples = 11, timeoutMs = 1200 }) {
    const results = [];

    for (let i = 0; i < samples; i++) {
        try {
        const ctrl = new AbortController();
        const to = setTimeout(() => ctrl.abort(), timeoutMs);

        const t0p = performance.now();
        const t0 = Date.now();

        // Use GET (not HEAD), and request a small static resource
        const res = await fetch(url, {
            method: "GET",
            cache: "no-store",
            credentials: "same-origin",
            signal: ctrl.signal,
        });

        const t1p = performance.now();
        const t1 = Date.now();

        clearTimeout(to);

        // Skip blocked/failed responses (403/401/etc)
        if (!res.ok) continue;

        const dateHeader = res.headers.get("date");
        if (!dateHeader) continue;

        const serverMs = new Date(dateHeader).getTime();
        if (!Number.isFinite(serverMs)) continue;

        const rtt = t1p - t0p;
        const localMid = (t0 + t1) / 2;
        const offset = serverMs - localMid;

        results.push({ offset, rtt });
        await new Promise(r => setTimeout(r, 80 + Math.random() * 40));
        } catch {
        // ignore failed sample
        }
    }

    if (!results.length) return { offsetMs: 0, jitterMs: null, bestRttMs: null, samplesUsed: 0 };

    results.sort((a,b) => a.rtt - b.rtt);
    const best = results[0];

    const top = results
        .slice(0, Math.min(5, results.length))
        .map(x => x.offset)
        .sort((a,b)=>a-b);

    const jitter = top.length >= 2 ? (top[top.length-1] - top[0]) : 0;

    return { offsetMs: best.offset, jitterMs: jitter, bestRttMs: best.rtt, samplesUsed: results.length };
    }

  // Button helpers
  function btn(){ return document.querySelector(BUTTON_SEL); }
  function highlight(el){ if(!el) return; el.classList.add('rcx-hl'); el.scrollIntoView({behavior:'smooth',block:'center'}); }

  // Safe single click
  function safeClick(){
    const b=btn();
    if(!b){ console.log('[rcx] No button to click'); return; }
    if (DRY_RUN){ console.log('[rcx] DRY RUN: would click', b); return; }
    console.log('[rcx] CLICK');
    b.dispatchEvent(new MouseEvent('click',{bubbles:true,cancelable:true}));
    if (typeof b.click === 'function') b.click();
  }

  // Optional beep
  let beep=()=>{}; if (BEEP) try{
    const ac=new (window.AudioContext||window.webkitAudioContext)();
    beep=(f=880,d=90,g=.16)=>{ const o=ac.createOscillator(),G=ac.createGain(); o.type='square'; o.frequency.value=f; G.gain.value=g; o.connect(G); G.connect(ac.destination); o.start(); setTimeout(()=>o.stop(),d); };
  }catch{}

  (async () => {
    // ✅ Offset is mutable (re-sync will update it if trustworthy)
    let offset = 0;

    // Initial sync (same-origin)
    const sync0 = await syncOffset({
      url: TIME_SYNC_URL,
      samples: TIME_SAMPLES,
      timeoutMs: TIME_TIMEOUT_MS
    });

    if (isGoodSync(sync0)) {
      offset = sync0.offsetMs || 0;
      $('rcx_s').textContent = fmtSync(sync0, 'synced');
    } else {
      offset = 0;
      $('rcx_s').textContent = `${fmtSync(sync0, 'synced')} | rejected → local clock`;
    }

    // Targets based on current offset
    const target = buildTarget(Date.now() + offset);
    const fireAt = new Date(target.getTime() + CLICK_ADJUST_MS);

    $('rcx_target').textContent = target.toLocaleTimeString();
    $('rcx_fire').textContent = fireAt.toLocaleTimeString() + (CLICK_ADJUST_MS ? ` (${CLICK_ADJUST_MS}ms)` : '');

    // Arm/highlight when button appears
    const arm=setInterval(()=>{ const b=btn(); if(b){ highlight(b); $('rcx_s').textContent += ' | button armed'; clearInterval(arm); } }, 200);

    // ✅ Schedule re-sync at T-30s (based on current offset estimate)
    if (RESYNC_ENABLED) {
      const resyncDelay = Math.max(0, (fireAt - (Date.now() + offset)) - RESYNC_AT_MS_BEFORE);

      setTimeout(async () => {
        const prev = offset;

        const sync1 = await syncOffset({
          url: TIME_SYNC_URL,
          samples: RESYNC_SAMPLES,
          timeoutMs: RESYNC_TIMEOUT_MS
        });

        let applied = false;
        if (isGoodSync(sync1)) {
          offset = sync1.offsetMs || 0;
          applied = true;
        }

        const delta = Math.round(offset - prev);
        $('rcx_s').textContent =
          `${fmtSync(sync0,'synced')} | ${fmtSync(sync1,'resync')} | ` +
          (applied ? `applied` : `rejected`) + ` | Δ${delta}ms`;
      }, resyncDelay);
    }

    // ALWAYS-ON countdown (every 200ms) — counts down to adjusted fire time
    let baseTimer = setInterval(() => {
      const now = Date.now() + offset;
      const diff = fireAt - now;
      const mm=Math.max(0, Math.floor(diff/60000));
      const ss=Math.max(0, Math.floor((diff%60000)/1000));
      const cs=Math.max(0, Math.floor((diff%1000)/10));
      $('rcx_t').textContent = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
    }, 200);

    // Upgrade to high-precision loop in final 5s (with beeps), then click at T=0
    const preDelay = Math.max(0, fireAt - (Date.now() + offset) - 5000);
    setTimeout(()=> {
      clearInterval(baseTimer);
      (function tick(){
        const now = Date.now() + offset;
        const diff = fireAt - now;

        if (diff <= 0){
          $('rcx_t').textContent='00:00.00';
          $('rcx_s').textContent += ' | GO';
          safeClick();
          return;
        }

        const mm=Math.floor(diff/60000);
        const ss=Math.floor((diff%60000)/1000);
        const cs=Math.floor((diff%1000)/10);
        $('rcx_t').textContent=`${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;

        if (mm===0 && ss<=5) beep(880,80,.2);
        requestAnimationFrame(tick);
      })();
    }, preDelay);
  })();
})();